---
layout: post
categories: unix
---

`1 week`
`1 person`

---
__Subject:__
##### Introduction:
```

```
##### Objectives:
```
This small project is about writing a library to handle dynamical memory allocation.
In order to be able to make it use by already existing programs without modifying or
recompiling them, you should rewrite malloc(3), free(3) and realloc(3) of the libc.
```
Your functions will be prototyped like those implemented on the system:
``` C
#include <stdlib.h>
void free(void *ptr);
void *malloc(size_t size);
void *realloc(void *ptr, size_t size);
```
```
• The malloc() function allocate “size” octets of memory and returns a pointer on
  the allocated memory.
• The realloc() function try to modify the size of the allocation pointed by “ptr”
  to “size” octets, and returns “ptr”. If there is not enough room at this memory
  location pointed by “ptr”, realloc() creates a new allocation and returns the a
  pointer on this new allocation.
• The free() function frees the memory allocation pointed by “ptr”. if “ptr” is
  NULL, free() does nothing.
• If an error occurs, the malloc() and realloc() functions return a NULL pointer.
• You must use the syscall mmap(2) and munmap(2) to claim and return memory to the
  system.
• You must handle your own memory allocations for the internal workings of your
  project, without using the libc malloc function.
• You must limit the numbers of call to mmap() in order to have better performances,
  but also to munmap(). You must then “pre-allocate” memory areas to store “tiny”
  et “small” malloc.
• The size of those areas must absolutely be a multiple of getpagesize().
```

```
• Chaque zone doit pouvoir contenir au moins 100 allocations.
◦ Les mallocs “TINY”, de 1 à n octets, seront stockés dans des zones de N octets
◦ Les mallocs “SMALL”, de (n+1) à m octets, seront stockés dans des zones de
M octets
◦ Les mallocs “LARGE”, de (m+1) octets et plus, seront stockés hors zone, c’est
à dire simplement avec un mmap(), ils seront en quelquesorte une zone à eux
tout seul.
• C’est à vous de définir la taille de n, m, N et M afin de trouver un bon compromis
entre vitesse (économie d’appel système) et économie de mémoire.
```
##### Constraints:
```

```
---
__Installation:__

* `git clone https://github.com/wwatkins42/42_C_Projects.git`
* `cd ./42_C_Projects/Malloc`
* `make`
* `./test/run.sh ./[file]`

**Usage:**
* `./test/run.sh ./[file]`
* `run.sh is a script used to inject my malloc library to use in executables instead of the default implementation of malloc.`

**Example:**
* `gcc ./test/test1 -o test1`
* `./test/run.sh /usr/bin/time -l ./test1`
